#!/usr/bin/perl

###############################################################################
#  Copyright (c) 2022-2024 Broadcom. All Rights Reserved.
#  Broadcom Confidential. The term "Broadcom" refers to Broadcom Inc.
#  and/or its subsidiaries.
###############################################################################

package RHEL9Customization;
use base qw(RHEL7Customization);

use strict;
use Debug;

# NetworkManager stores new network profiles in keyfile format in
# the /etc/NetworkManager/system-connections directory
my $NMKEYFILEPROFILEDIR = "/etc/NetworkManager/system-connections";
my $NMKEYFILEPROFILEEXT = ".nmconnection";
my $NMKEYFILEPROFILEPREFIX = "VMware-customization-";
my $NMKEYFILEPROFILEUSERORIGIN = "VMware customization";

sub FindOsId
{
   my ($self, $content) = @_;
   my $result = undef;

   if ($content =~ /Red.*Hat.*Enterprise.*Linux.*\s+(\d{1,2})/i) {
      if ($1 >= 9) {
         $result = "Red Hat Enterprise Linux $1";
      }
   } elsif ($content =~ /CentOS.*?release\s+(\d{1,2})/i) {
      if ($1 >= 9) {
         $result = $RHEL7Customization::CENTOS . " $1";
      }
   } elsif ($content =~ /Oracle.*?release\s+(\d{1,2})/i) {
      if ($1 >= 9) {
         $result = $RHEL7Customization::ORA . " $1";
      }
   } elsif ($content =~ /Rocky.*?release\s+(\d{1,2})/i) {
      # Match Rocky Linux 9.x
      if ($1 >= 9) {
         $result = $RHEL7Customization::ROCKY . " $1";
      }
   } elsif ($content =~ /Alma.*?release\s+(\d{1,2})/i) {
      # Match Alma Linux 9.x
      if ($1 >= 9) {
         $result = $RHEL7Customization::ALMA . " $1";
      }
   } elsif ($content =~ /MIRACLE.*?release\s+(\d{1,2})/i) {
      # Match Miracle Linux 9.x
      if ($1 >= 9) {
         $result = $RHEL7Customization::MIRACLE . " $1";
      }
   }
   return $result;
}

sub CustomizeNetwork
{
   my ($self) = @_;

   RemoveOldNMKeyfileProfiles();

   $self->SUPER::CustomizeNetwork();
}

#...............................................................................
#
# RemoveOldNMKeyfileProfiles
#
#   Delete old NetworkManager keyfile profiles under directory
#   /etc/NetworkManager/system-connections
#
# Params:
#   None.
#
# Result:
#   None.
#
#...............................................................................

sub RemoveOldNMKeyfileProfiles
{
   # NetworkManager loads files under directory
   # /etc/NetworkManager/system-connections regardless of filename.
   INFO("Removing old NetworkManager network profiles in keyfile format");
   my $keyfileProfilePattern = $NMKEYFILEPROFILEDIR . "/*";
   Utils::DeleteFiles(glob($keyfileProfilePattern));
}

#...............................................................................
#
# WriteNMKeyfileProfile
#
#   Write network configuration for the associated network card to the
#   NetworkManager keyfile profile.
#
# Params:
#   $nic        the associated network card
#
# Result:
#   None.
#
#...............................................................................

sub WriteNMKeyfileProfile
{
   my ($self, $nic) = @_;

   # Get the interface
   my $macaddr = $self->{_customizationConfig}->Lookup($nic . "|MACADDR");
   my $interface = $self->GetInterfaceByMacAddress($macaddr);

   if (!$interface) {
      die "Error finding the specified NIC (MAC address = $macaddr)";
   }

   INFO("Writing NetworkManager keyfile profile for NIC suffix = $interface");
   # Write the network profile in keyfile format
   my @content = $self->FormatNMKeyfileProfileContent($nic, $interface);
   unshift(@content, "# Generated by VMware customization engine.\n");
   my $keyfileProfile =
      $self->GetNMKeyfileProfilePrefix() . $interface . $NMKEYFILEPROFILEEXT;
   DEBUG("Content of Keyfile profile $keyfileProfile\n@content");
   Utils::WriteBufferToFile($keyfileProfile, \@content);
   # keyfile profile should be made readable only to root.
   Utils::SetPermission($keyfileProfile, $Utils::RW00);
}

sub CustomizeSpecificNIC
{
   my ($self, $nic) = @_;

   # Write network configuration to NetworkManager keyfile profile
   $self->WriteNMKeyfileProfile($nic);

   # Besides keyfile profile, ifcfg-rh profile is still supported by
   # NetworkManager for RHEL 9.x. In case some customers are using ifcfg-rh
   # profile, we still write network configuration to network-scripts.
   # RHEL has fully deprecated ifcfg-rh profile in RHEL 10.x, so we stop
   # supporting it since RHEL 10.0.
   $self->SUPER::CustomizeSpecificNIC($nic);
}

#...............................................................................
#
# GetNMKeyfileProfilePrefix
#
#
# Params:
#   None.
#
# Result:
#   Return a prefix (without the interface and extension) of the path to a
#   keyfile profile created by VMware customization engine.
#
#...............................................................................

sub GetNMKeyfileProfilePrefix
{
   my ($self) = @_;

   return $NMKEYFILEPROFILEDIR . "/" . $NMKEYFILEPROFILEPREFIX;
}

#...............................................................................
#
# FormatNMKeyfileProfileContent
#
#   Formats the content of the NetworkManager keyfile profile.
#   A NetworkManager property is stored in the keyfile as a variable of the same
#   name and in the same format. There are several exceptions to this rule,
#   mainly for making keyfile syntax easier for humans.
#   man (5) nm-settings
#   man (5) nm-settings-keyfile
#
# Params:
#   $nic        the associated network card
#   $interface  the associated network interface
#
# Result:
#   Arrary with formatted lines.
#
#...............................................................................

sub FormatNMKeyfileProfileContent
{
   my ($self, $nic, $interface) = @_;

   # Get the params
   my $onboot      = $self->{_customizationConfig}->Lookup($nic . "|ONBOOT");
   my $bootproto   = $self->{_customizationConfig}->Lookup($nic . "|BOOTPROTO");
   my $dnsfromdhcp = $self->{_customizationConfig}->Lookup("DNS|DNSFROMDHCP");
   my $ipv4Mode    = $self->{_customizationConfig}->GetIpV4Mode($nic);
   my $macaddr     = $self->{_customizationConfig}->GetMACAddress($nic);
   my $primaryNic  = $self->{_customizationConfig}->GetPrimaryNic();

   my @content;

   # Format [connection] section
   push(@content, "\n[connection]\n");
   my $id = $NMKEYFILEPROFILEUSERORIGIN . " " . $interface;
   push(@content, "id=$id\n");
   my $uuid = Utils::GetUUID();
   if ($uuid) {
      push(@content, "uuid=$uuid");
   }
   push(@content, "type=ethernet\n");
   push(@content, "interface-name=$interface\n");
   # When autoconnect is omit, its value is true by default
   if ($onboot =~ /yes/i) {
      push(@content, "autoconnect=true\n");
   } elsif ($onboot =~ /no/i) {
      push(@content, "autoconnect=false\n");
   }

   # Format [user] section
   # This is not actually used anywhere, but may be useful in future
   push(@content, "\n[user]\n");
   push(@content,
      "org.freedesktop.NetworkManager.origin=$NMKEYFILEPROFILEUSERORIGIN\n");

   # Format [ethernet] section
   push(@content, "\n[ethernet]\n");
   push(@content, "mac-address=$macaddr\n");

   # Format [ipv4] section
   push(@content, "\n[ipv4]\n");
   my $ipv4Method;
   if ($ipv4Mode eq $ConfigFile::IPV4_MODE_DISABLED) {
      INFO("Marking $interface as IPv4-disabled (method=disabled)");
      $ipv4Method = "disabled";
   } else {
      if ($bootproto =~ /dhcp/i) {
         $ipv4Method = "auto";
         if ($dnsfromdhcp =~ /yes/i) {
            push(@content, "ignore-auto-dns=false\n");
         } elsif ($dnsfromdhcp =~ /no/i) {
            push(@content, "ignore-auto-dns=true\n");
         }
      } else {
         $ipv4Method = "manual";
         my $ipv4Addr = $self->GetIpv4Address($nic);
         if ($ipv4Addr) {
            push(@content, "address1=$ipv4Addr\n");
         }
      }
   }
   push(@content, "method=$ipv4Method\n");
   # [ipv4] Gateway
   my @ipv4Gateways =
      split(/,/, $self->{_customizationConfig}->Lookup($nic . "|GATEWAY"));
   if (@ipv4Gateways) {
      if ((defined $primaryNic) and ($primaryNic ne $nic)) {
         INFO("SKIPPING default gw4 for non-primary NIC '$nic'");
         INFO("NIC '$nic' will not be the default connection for ipv4");
         push(@content, "never-default=true\n");
      } else {
         # Multiple gateways lead to network configuration failure and
         # customer should be advised to use a single gateway
         my $gw4 = @ipv4Gateways[0];
         push(@content, "gateway=$gw4\n");
      }
   }
   # [ipv4] name server and search domain
   my $nameServers = $self->{_customizationConfig}->GetNameServers();
   my $dnsSuffixes = $self->{_customizationConfig}->GetDNSSuffixes();
   if ($nameServers && @$nameServers) {
      my $dns = join(";", @$nameServers);
      push(@content, "dns=$dns\n");
   }
   if ($dnsSuffixes && @$dnsSuffixes) {
      my $dnsSearch = join(";", @$dnsSuffixes);
      push(@content, "dns-search=$dnsSearch\n");
   }

   # Format [ipv6] section
   push(@content, "\n[ipv6]\n");
   my $ipv6Method;
   my @ipv6Addrs = $self->GetIpv6Addresses($nic);
   if (@ipv6Addrs) {
      for (my $index = 0; $index <= $#ipv6Addrs; $index++) {
         my $addrIndex = $index + 1;
         push(@content,
            "address" . $addrIndex . "=" . $ipv6Addrs[$index] . "\n");
      }
      $ipv6Method = "manual";
   } else {
      $ipv6Method = "auto";
   }
   push(@content, "method=$ipv6Method\n");
   # [ipv6] Gateway
   my @ipv6Gateways = ConfigFile::ConvertToArray(
      $self->{_customizationConfig}->Query("^$nic(\\|IPv6GATEWAY\\|)"));
   if (@ipv6Gateways) {
      if ((defined $primaryNic) and ($primaryNic ne $nic)) {
         INFO("SKIPPING default gw6 for non-primary NIC '$nic'");
         INFO("NIC '$nic' will not be the default connection for ipv6");
         push(@content, "never-default=true\n");
      } else {
         # Multiple gateways lead to network configuration failure and
         # customer should be advised to use a single gateway
         my $gw6 = @ipv6Gateways[0];
         push(@content, "gateway=$gw6\n");
      }
   }
   return @content;
}

#...............................................................................
#
# GetIpv4Address
#
#   Get the IPv4 address/prefix format string (CIDR notation).
#   Note that our spec only supports one IPv4 address per NIC.
#   This is why we are returning a scalar.
#
# Params:
#   $nic   the associated network card
#
# Result:
#   A formatted IPv4 address/prefix string
#
#...............................................................................

sub GetIpv4Address
{
   my ($self, $nic) = @_;
   my $result;

   my $ipaddr  = $self->{_customizationConfig}->Lookup($nic . "|IPADDR");
   my $netmask = $self->{_customizationConfig}->Lookup($nic . "|NETMASK");

   if ($ipaddr and $netmask) {
      my @parts = split(/\./, $netmask);
      my $prefix = 0;
      for my $part (@parts) {
         $prefix += Utils::CountBits($part);
      }
      $result = $ipaddr . "/" . $prefix;
   }

   return $result;
}

#...............................................................................
#
# GetIpv6Addresses
#
#   Get the IPv6 address/prefix format strings (CIDR notations).
#   Note that our spec supporst multiple IPv6 addresses per NIC.
#   This is why we are returning an array.
#
# Params:
#   $nic   the associated network card.
#
# Result:
#   An array of formatted IPv6 address/prefix strings.
#
#...............................................................................

sub GetIpv6Addresses
{
   my ($self, $nic) = @_;
   my @result;

   my @ipv6Addresses = ConfigFile::ConvertToIndexedArray(
      $self->{_customizationConfig}->Query("^($nic\\|IPv6ADDR\\|)"));
   my @ipv6Netmasks = ConfigFile::ConvertToIndexedArray(
      $self->{_customizationConfig}->Query("^($nic\\|IPv6NETMASK\\|)"));
   my @ipv6Settings = ConfigFile::Transpose(\@ipv6Addresses, \@ipv6Netmasks);

   for my $ipv6Setting (@ipv6Settings) {
      push(@result, $ipv6Setting->[0] . "/" . $ipv6Setting->[1]);
   }

   return @result;
}

sub RestartNetwork
{
   my ($self)  = @_;
   my $returnCode;

   # Deactivate all interfaces managed by NetworkManager
   Utils::ExecuteCommand('nmcli networking off 2>&1',
                         'Deactivate all interfaces',
                         \$returnCode);
   if ($returnCode) {
      die "Failed to deactivate interfaces, return code: $returnCode";
   }

   # Reload connection profiles from disk
   Utils::ExecuteCommand('nmcli con reload',
                         'Reload connection profiles',
                         \$returnCode);
   if ($returnCode)  {
      die "Failed to reload connection profiles, return code: $returnCode";
   }

   # Activate all interfaces managed by NetworkManager
   Utils::ExecuteCommand('nmcli networking on 2>&1',
                         'Activate all interfaces',
                         \$returnCode);
   if ($returnCode) {
      die "Failed to activate interfaces, return code: $returnCode";
   }

   # Restart NetworkManager.service
   Utils::ExecuteCommand('systemctl restart NetworkManager.service 2>&1',
                         'Restart NetworkManager.service',
                         \$returnCode);
   if ($returnCode) {
      die "Failed to restart NetworkManager.service, return code: $returnCode";
   }
}

1;
