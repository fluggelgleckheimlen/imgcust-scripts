#!/usr/bin/perl

########################################################################################
#  Copyright 2008-2017 VMware, Inc.  All rights reserved.
########################################################################################

#.......................................................................................
#
# TimezoneDB.pm
#
#  This module implements timezone database API.
#
# THE TIMEZONE DATABASE - The tzdata DIRECTORY MUST BE IN THIS SCRIPT'S DIR!
#
# TIMEZONE DATABASE UPDATE STEPS:
#     1. DOWNLOAD LATEST VERSION FROM FTP://ELSIE.NCI.NIH.GOV/PUB/
#     2. EXTRACT THE DOWNLOADED DATABASE IN the tzdata DIR
#     3. UPDATE THE VERSION FILE in the tzdata DIR
#
#.......................................................................................

use strict;

package TimezoneDB;

use Debug;

#  A timezone database may contain some of these files that should not be compiled,
#  but rather used in another way.

# Allowance for leapseconds added to each timezone file.
my $TZDBLEAPSECONDSFILE   = "leapseconds";

my $TZDBYEARISTYPEFILE    = "yearistype.sh";

# TZ zone descriptions
my $TZDBZONETABFILE       = "zone.tab";
my $TZDBZONE1970TABFILE   = "zone1970.tab";

# Country codes
my $TZDBISO3166TABFILE    = "iso3166.tab";

# Needed to track versions. Not present in the original tzdata*.tar.gz.
my $TZDBVERSION           = "VERSION";

my @TZDBNONTIMEZONEFILES  = (
   $TZDBLEAPSECONDSFILE,
   $TZDBYEARISTYPEFILE,
   $TZDBZONETABFILE,
   $TZDBZONE1970TABFILE,
   $TZDBISO3166TABFILE,
   $TZDBVERSION,
   "README", "CONTRIBUTING", "Makefile", "Theory", "NEWS",
   "checklinks.awk", "checktab.awk", "leapseconds.awk", "leap-seconds.list",
   "zoneinfo2tdf.pl", "theory.html", "calendars", "zishrink.awk",
   "ziguard.awk");

#.......................................................................................
#
# GetPath
#  Finds the path to the timezone database
#
# Params:
#   None
#
# Result:
#   The first timezone database path found or undef if no database is found
#.......................................................................................

sub GetPath()
{
   my $result = undef;

   my $path = Utils::ExtractDirFromPath(__FILE__) . "/tzdata";

   if (-d $path) {
      $result = $path;
   }

   return $result;
}

#.......................................................................................
#
# GetVersion
#
# Params:
#   None
#
# Result:
#   The version of the timezone database, e.g. tzdata2007k
#.......................................................................................

sub GetVersion()
{
   my @verLines = Utils::ReadFileIntoBuffer(GetPath() . "/$TZDBVERSION");
   return ($#verLines >= 0) ? $verLines[0] : "";
}

#.......................................................................................
#
# GetTimeZoneFiles
#  Finds all time zone files in the time zone database.
#
# Params:
#   None
#
# Result:
#   Array with time zone filenames relative to the current path.
#.......................................................................................

sub GetTimeZoneFiles
{
   my %tzDBnonTZfiles = map {lc($_) => 1} @TZDBNONTIMEZONEFILES;

   return
      grep
         {not exists $tzDBnonTZfiles{lc(Utils::ExtractFileFromPath($_))}}
         glob(GetPath() . "/*");
}

#.......................................................................................
#
# InstallTimeZonesFromTZDB
#  Installs time zones from the database.
#
# Params:
#   None
#
# Result:
#   true on successful installation, false otherwise
#.......................................................................................

sub Install
{
   my ($tzPath) = @_;

   # Compile time zone information from all available time zones in the database
   my $zicReturnCode = -1;

   # LeapSeconds option is omitted because not all versions of zic (SunSolaris) have it
   # Use the default YearIsType option
   my @tzfiles = GetTimeZoneFiles();

   # If any warnings are generated by 'zic' command on stderr, the deploypkg plugin
   # treats the guest customization as failed. So redirect stderr to stdout
   Utils::ExecuteCommand(
      "zic @tzfiles 2>&1",
      "Installing timezones...",
      \$zicReturnCode);

   # Copy country codes and capital latitude-longitutde files.
   my $tzdbpath = GetPath();
   Utils::ExecuteCommand("cp -f $tzdbpath/$TZDBZONETABFILE $tzPath");
   Utils::ExecuteCommand("cp -f $tzdbpath/$TZDBISO3166TABFILE $tzPath");

   return $zicReturnCode == 0 ? 1 : 0;
}

#.......................................................................................
#
# DeduceGMTTimezone
#  Searches for a timezone GMT offset in the timezone databse.
#
# Params:
#   $tzRegionCity - timezone in the Region/City format
#
# Result:
#   A string specifying the timezone by GMT
#.......................................................................................

sub DeduceGMTTimezone
{
   my ($tzRegionCity) = @_;
   return GetTimeZoneByGMTOffset(GetTimeZoneGMTOffsetFromTZDB($tzRegionCity))
}

#.......................................................................................
#
# ReadZoneGMTOffsetFromTZDB
#  Searches for a Zone rule in the timezone databse.
#
# Params:
#   $tzdb - an array ref for the timezone database
#   $tzRegionCity - timezone in the region/city format for which to search
#
# Result:
#   The GMT offset H in the sense that UTC+H=LOCALTIME if
#   information on $tzRegionCity is available or undef otherwise.
#.......................................................................................

sub ReadZoneGMTOffsetFromTZDB
{
   my ($tzdb, $tzRegionCity) = @_;

   my $tzGMTOff = undef;
   my @tzdb = @{$tzdb};

   my $zoneLineIndex =
      Utils::FindLineInBuffer(
         "Zone(.*)$tzRegionCity",
         $tzdb,
         $Utils::SMDONOTSEARCHCOMMENTS);

   if ($zoneLineIndex >= 0) {
      my @zoneCols =
         split(
            /\s+/,
            Utils::Trim(Utils::GetLineWithoutComments($tzdb[$zoneLineIndex])));

      if ($#zoneCols >= 1) {
         $tzGMTOff = int($zoneCols[1]);
      }

      foreach ($zoneLineIndex + 1 .. $#tzdb) {
         my $line = Utils::Trim(Utils::GetLineWithoutComments($tzdb[$_]));

         if ((not $line) or
            $line =~ /zone/i or
            $line =~ /rule/i or
            $line =~ /link/i) {
            last;
         }

         my @cols = split(/\s+/, $line);

         if ($#cols >= 0) {
            $tzGMTOff = $cols[0];
         }
      }
   }

   return $tzGMTOff;
}

#.......................................................................................
#
# GetTimeZoneGMTOffsetFromTZDB
#  Searches for a timezone GMT offset in the timezone databse.
#
# Params:
#   $tzRegionCity - timezone in the Region/City format
#
# Result:
#   The GMT offset H in the sense that UTC+H=LOCALTIME if
#   information on  $tzRegionCity is available or undef otherwise.
#.......................................................................................

sub GetTimeZoneGMTOffsetFromTZDB
{
   my ($tzRegionCity) = @_;

   # Read the timezone database.
   my @tzdb = ();

   foreach (GetTimeZoneFiles()) {
      push(@tzdb, Utils::ReadFileIntoBuffer($_));
   }

   # Deduce the timezone GMT offset.
   my $tzGMTOff = undef;

   my $tzdbZoneGMTOff = ReadZoneGMTOffsetFromTZDB(\@tzdb, $tzRegionCity);

   if ($tzdbZoneGMTOff) {
      # A Zone for region/city is found. Get only the hour offset.
      $tzGMTOff = int($tzdbZoneGMTOff);
   } else {
      # Check whether the region/city is linked to another region/city.
      my $linkLineIndex =
         Utils::FindLineInBuffer(
            "Link(.*)$tzRegionCity",
            \@tzdb,
            $Utils::SMDONOTSEARCHCOMMENTS);

      if ($linkLineIndex >= 0) {
         my @linkCols =
            split(
               /\s+/,
               Utils::Trim(Utils::GetLineWithoutComments($tzdb[$linkLineIndex])));

         if ($#linkCols >= 1) {
            my $refTZ = $linkCols[1];
            $tzGMTOff = int(ReadZoneGMTOffsetFromTZDB(\@tzdb, $refTZ));
         }
      }
   }

   return $tzGMTOff;
}

#.......................................................................................
#
# GetTimeZoneByGMTOffset
#  Gets the timezone by a GMT offset.
#
# Params:
#   $gmtOff - an integer for the GMT offset, such that UTC+$gmtOff=LOCALTIME
#
# Result:
#  A string specifying the timezone by GMT.
#
# NOTE:
#  GMT+H has the following meaning: add H to your local time to obtain
#  the UTC time, i.e LOCAL + H = UTC
#.......................................................................................

sub GetTimeZoneByGMTOffset
{
   my ($gmtOff) = @_;

   my $formattedGMTOff = undef;

   if (defined $gmtOff) {
      my $absGMTOff = abs($gmtOff);
      $formattedGMTOff = $gmtOff > 0 ? "Etc/GMT-$absGMTOff" : "Etc/GMT+$absGMTOff";
   }

   return $formattedGMTOff;
}

#.......................................................................................
#
# GetTimezonesList
#  Gets the timezones that are int the timezone database.
#
# Result:
#  A list of timezones from the database
#
#.......................................................................................

sub GetTimezonesList
{
   my @tzdb = ();

   foreach (GetTimeZoneFiles()) {
      push(@tzdb, Utils::ReadFileIntoBuffer($_));
   }

   my @timezones = ();

   foreach (@tzdb) {
      my @tzdbCols = split(/\s+/, Utils::Trim(Utils::GetLineWithoutComments($_)));

      if ($#tzdbCols >= 2) {
         if ($tzdbCols[0] =~ /zone/i) {
         push(@timezones, $tzdbCols[1]);
         } elsif ($tzdbCols[0] =~ /link/i) {
            push(@timezones, $tzdbCols[2]);
         }
      }
   }

   return @timezones;
}

#.......................................................................................
#
# GetRenamedTimezoneInfo
#  Gets info about a renamed timezone.
#
# Params:
#     $tz - new or old tz name
#
# Result:
#  A non-empty hash if the tz has been renamed
#  Keys
#     - _currentName - the current tz name
#     - _oldName     - the old(previous) tz name
#
#.......................................................................................

sub GetRenamedTimezoneInfo($)
{
   my ($tz) = @_;

   my %result = ();

   foreach (Utils::ReadFileIntoBuffer(GetPath() . '/backward')) {
      my @tzdbCols = split(/\s+/, Utils::Trim(Utils::GetLineWithoutComments($_)));

      if ($#tzdbCols >= 2 &&
          $tzdbCols[0] =~ /link/i &&
          ($tzdbCols[1] =~ /^$tz$/i || $tzdbCols[2] =~ /^$tz$/i)) {

         $result{_currentName} = $tzdbCols[1];
         $result{_oldName} = $tzdbCols[2];
         last;
      }
   }

   return %result;
}

1;
